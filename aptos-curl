#!/bin/bash

# aptos-curl - Download Aptos/Movement package source code
# Version: 1.0.0

set -e

VERSION="1.0.0"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Global variables
ACCOUNT=""
OUTPUT_DIR=""
NETWORK="aptos-mainnet"
FORCE=false
VERBOSE=false

# Network URLs mapping
get_fullnode_url() {
    case "$1" in
        aptos-mainnet)
            echo "https://rpc.sentio.xyz/aptos/v1"
            ;;
        aptos-testnet)
            echo "https://api.testnet.aptoslabs.com/v1"
            ;;
        aptos-devnet)
            echo "https://api.devnet.aptoslabs.com/v1"
            ;;
        movement-mainnet)
            echo "https://rpc.sentio.xyz/movement/v1"
            ;;
        movement-testnet)
            echo "https://full.testnet.movementinfra.xyz/v1"
            ;;
        *)
            echo ""
            ;;
    esac
}

# Print functions
print_error() {
    echo -e "${RED}Error: $1${NC}" >&2
}

print_success() {
    echo -e "${GREEN}$1${NC}"
}

print_info() {
    echo -e "${BLUE}$1${NC}"
}

print_warning() {
    echo -e "${YELLOW}$1${NC}"
}

print_verbose() {
    if [ "$VERBOSE" = true ]; then
        echo "$1"
    fi
}

# Show help
show_help() {
    cat << EOF
aptos-curl v${VERSION} - Download Aptos/Movement package source code

USAGE:
    aptos-curl -a <ADDRESS> -o <OUTPUT_DIR> [OPTIONS]

REQUIRED:
    -a, --account <ADDRESS>    Account address to download packages from
    -o, --output <DIR>         Output directory for downloaded packages

OPTIONS:
    -n, --network <NETWORK>    Network to use (default: aptos-mainnet)
                               Options: aptos-mainnet, aptos-testnet, aptos-devnet,
                                        movement-mainnet, movement-testnet
    -f, --force                Overwrite existing output directory
    -v, --verbose              Show detailed output
    -h, --help                 Show this help message
    --version                  Show version information

EXAMPLES:
    # Download from Aptos mainnet
    aptos-curl -a 0x1234... -o ./packages

    # Download from Movement testnet with verbose output
    aptos-curl -a 0x1234... -o ./packages -n movement-testnet -v

    # Force overwrite existing directory
    aptos-curl -a 0x1234... -o ./packages -f
EOF
}

# Validate dependencies
validate_dependencies() {
    local missing_deps=()

    if ! command -v aptos &> /dev/null; then
        missing_deps+=("aptos")
    fi

    if ! command -v jq &> /dev/null; then
        missing_deps+=("jq")
    fi

    if ! command -v curl &> /dev/null; then
        missing_deps+=("curl")
    fi

    if [ ${#missing_deps[@]} -gt 0 ]; then
        print_error "Missing required dependencies: ${missing_deps[*]}"
        echo "Please install them before running this script."
        exit 1
    fi
}

# Validate account address
validate_address() {
    local addr="$1"

    # Remove 0x prefix if present for validation
    addr="${addr#0x}"

    # Check if it's a valid hex string (1-64 characters)
    if ! [[ "$addr" =~ ^[0-9a-fA-F]{1,64}$ ]]; then
        print_error "Invalid account address format. Must be a hex string with optional 0x prefix."
        exit 1
    fi
}

# Validate network
validate_network() {
    local url=$(get_fullnode_url "$1")
    if [ -z "$url" ]; then
        print_error "Invalid network: $1"
        echo "Valid networks: aptos-mainnet, aptos-testnet, aptos-devnet, movement-mainnet, movement-testnet"
        exit 1
    fi
}

# Parse command line arguments
parse_args() {
    if [ $# -eq 0 ]; then
        show_help
        exit 0
    fi

    while [ $# -gt 0 ]; do
        case "$1" in
            -a|--account)
                ACCOUNT="$2"
                shift 2
                ;;
            -o|--output)
                OUTPUT_DIR="$2"
                shift 2
                ;;
            -n|--network)
                NETWORK="$2"
                shift 2
                ;;
            -f|--force)
                FORCE=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            --version)
                echo "aptos-curl v${VERSION}"
                exit 0
                ;;
            *)
                print_error "Unknown option: $1"
                echo "Use -h or --help for usage information."
                exit 1
                ;;
        esac
    done

    # Validate required arguments
    if [ -z "$ACCOUNT" ]; then
        print_error "Account address is required. Use -a or --account."
        exit 1
    fi

    if [ -z "$OUTPUT_DIR" ]; then
        print_error "Output directory is required. Use -o or --output."
        exit 1
    fi

    # Add 0x prefix if not present
    if [[ ! "$ACCOUNT" =~ ^0x ]]; then
        ACCOUNT="0x${ACCOUNT}"
    fi
}

# Check if package has source code available
has_source_code() {
    local url="$1"
    local account="$2"
    local package_name="$3"

    print_verbose "  Checking if source code is available..."

    local response=$(curl -s "${url}/accounts/${account}/resource/0x1::code::PackageRegistry" 2>/dev/null)

    if [ -z "$response" ]; then
        print_verbose "  Failed to fetch package registry"
        return 1
    fi

    # Check if any module in this package has source code (not "0x")
    local has_source=$(echo "$response" | jq -r --arg pkg "$package_name" '
        .data.packages[] |
        select(.name == $pkg) |
        .modules[0].source != "0x"
    ' 2>/dev/null)

    if [ "$has_source" = "true" ]; then
        return 0
    else
        return 1
    fi
}

# Download package with source code
download_with_source() {
    local url="$1"
    local account="$2"
    local package_name="$3"
    local output_dir="$4"

    print_verbose "  Downloading with source code..."

    if [ "$VERBOSE" = true ]; then
        aptos move download --account "$account" --package "$package_name" --url "$url" --output-dir "$output_dir"
    else
        aptos move download --account "$account" --package "$package_name" --url "$url" --output-dir "$output_dir" > /dev/null 2>&1
    fi

    if [ $? -eq 0 ]; then
        return 0
    else
        return 1
    fi
}

# Download and decompile package
download_and_decompile() {
    local url="$1"
    local account="$2"
    local package_name="$3"
    local output_dir="$4"

    print_verbose "  Downloading bytecode..."

    if [ "$VERBOSE" = true ]; then
        aptos move download --account "$account" --bytecode --package "$package_name" --url "$url" --output-dir "$output_dir"
    else
        aptos move download --account "$account" --bytecode --package "$package_name" --url "$url" --output-dir "$output_dir" > /dev/null 2>&1
    fi

    if [ $? -ne 0 ]; then
        print_warning "  Failed to download package: $package_name"
        return 1
    fi

    print_verbose "  Removing old sources..."
    rm -rf "${output_dir}/${package_name}/sources" 2>/dev/null

    print_verbose "  Decompiling..."

    if [ "$VERBOSE" = true ]; then
        aptos move decompile --package-path "${output_dir}/${package_name}/bytecode_modules" --output-dir "${output_dir}/${package_name}/sources" --decompiler-version v2
    else
        aptos move decompile --package-path "${output_dir}/${package_name}/bytecode_modules" --output-dir "${output_dir}/${package_name}/sources" --decompiler-version v2 > /dev/null 2>&1
    fi

    if [ $? -ne 0 ]; then
        print_warning "  Failed to decompile package: $package_name"
        return 1
    fi

    print_verbose "  Renaming .mv.move to .move..."
    find "${output_dir}/${package_name}/sources" -name '*.mv.move' -exec sh -c 'mv "$0" "${0%.mv.move}.move"' {} \; 2>/dev/null

    return 0
}

# Main function
main() {
    parse_args "$@"

    print_info "aptos-curl v${VERSION}"
    echo ""

    # Validate dependencies
    validate_dependencies

    # Validate inputs
    validate_address "$ACCOUNT"
    validate_network "$NETWORK"

    local url=$(get_fullnode_url "$NETWORK")

    # Handle output directory
    if [ -d "$OUTPUT_DIR" ]; then
        if [ "$FORCE" = false ]; then
            print_error "Output directory already exists: $OUTPUT_DIR"
            echo "Use -f or --force to overwrite."
            exit 1
        else
            print_info "Removing existing directory: $OUTPUT_DIR"
            rm -rf "$OUTPUT_DIR"
        fi
    fi

    # Create output directory
    mkdir -p "$OUTPUT_DIR"

    print_info "Network: $NETWORK"
    print_info "Account: $ACCOUNT"
    print_info "Output: $OUTPUT_DIR"
    echo ""

    # Fetch package names
    print_info "Fetching package list..."
    local pkg_names=$(curl -s "${url}/accounts/${ACCOUNT}/resource/0x1::code::PackageRegistry" | jq -r '.data.packages[].name' 2>/dev/null)

    if [ -z "$pkg_names" ]; then
        print_error "Failed to fetch packages or no packages found at this address."
        exit 1
    fi

    local total_packages=$(echo "$pkg_names" | wc -l | tr -d ' ')
    print_success "Found $total_packages package(s)"
    echo ""

    local with_source=0
    local decompiled=0
    local failed=0
    local current=0

    # Process each package
    while IFS= read -r pkg_name; do
        current=$((current + 1))
        print_info "[$current/$total_packages] Processing: $pkg_name"

        if has_source_code "$url" "$ACCOUNT" "$pkg_name"; then
            echo "  Source code available - downloading..."
            if download_with_source "$url" "$ACCOUNT" "$pkg_name" "$OUTPUT_DIR"; then
                print_success "  ✓ Downloaded with source code"
                with_source=$((with_source + 1))
            else
                print_warning "  ✗ Failed to download"
                failed=$((failed + 1))
            fi
        else
            echo "  No source code - decompiling..."
            if download_and_decompile "$url" "$ACCOUNT" "$pkg_name" "$OUTPUT_DIR"; then
                print_success "  ✓ Decompiled successfully"
                decompiled=$((decompiled + 1))
            else
                print_warning "  ✗ Failed to decompile"
                failed=$((failed + 1))
            fi
        fi
        echo ""
    done <<< "$pkg_names"

    # Summary
    print_info "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    print_success "Summary:"
    echo "  Total packages: $total_packages"
    echo "  With source code: $with_source"
    echo "  Decompiled: $decompiled"
    if [ $failed -gt 0 ]; then
        print_warning "  Failed: $failed"
    fi
    print_info "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
}

main "$@"
